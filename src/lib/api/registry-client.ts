import { ConfigManager } from '../../utils/config-manager.js';
import type { paths } from './schema.js';

// =============================================================================
// Types derived from OpenAPI schema (generated by openapi-typescript)
// =============================================================================

// Helper to extract response type from path
type ResponseOf<T> = T extends { responses: { 200: { content: { 'application/json': infer R } } } } ? R : never;

// V1 API Response Types
export type BundleSearchResponse = ResponseOf<paths['/v1/bundles/search']['get']>;
export type BundleDetailResponse = ResponseOf<paths['/v1/bundles/@{scope}/{package}']['get']>;
export type VersionsResponse = ResponseOf<paths['/v1/bundles/@{scope}/{package}/versions']['get']>;
export type DownloadInfoResponse = ResponseOf<paths['/v1/bundles/@{scope}/{package}/versions/{version}/download']['get']>;

// Convenience aliases
export type Bundle = BundleSearchResponse['bundles'][number];
export type BundleDetail = BundleDetailResponse;
export type VersionInfo = VersionsResponse['versions'][number];
export type DownloadInfo = DownloadInfoResponse;

/** Platform identifier (os + arch) */
export interface Platform {
  os: string;  // darwin, linux, win32, any
  arch: string; // x64, arm64, any
}

// =============================================================================
// Registry Client (v1 API only)
// =============================================================================

/**
 * Client for interacting with the mpak registry v1 API
 *
 * All methods use the public /v1/bundles API (unauthenticated)
 */
export class RegistryClient {
  private baseUrl: string;

  constructor() {
    const configManager = new ConfigManager();
    this.baseUrl = configManager.getRegistryUrl();
  }

  /**
   * Search bundles
   */
  async searchBundles(query: string, options: {
    type?: string;
    sort?: 'downloads' | 'recent' | 'name';
    limit?: number;
    offset?: number;
  } = {}): Promise<BundleSearchResponse> {
    const params = new URLSearchParams();
    if (query) params.set('q', query);
    if (options.type) params.set('type', options.type);
    if (options.sort) params.set('sort', options.sort);
    if (options.limit) params.set('limit', options.limit.toString());
    if (options.offset) params.set('offset', options.offset.toString());

    const url = `${this.baseUrl}/v1/bundles/search?${params.toString()}`;
    const response = await fetch(url);

    if (!response.ok) {
      const error: any = await response.json().catch(() => ({ error: response.statusText }));
      const errorMessage = typeof error.error === 'string'
        ? error.error
        : error.error?.message || `Failed to search bundles: ${response.statusText}`;
      throw new Error(errorMessage);
    }

    return response.json() as Promise<BundleSearchResponse>;
  }

  /**
   * Get bundle details
   */
  async getBundle(packageName: string): Promise<BundleDetail> {
    if (!packageName.startsWith('@')) {
      throw new Error('Package name must be scoped (e.g., @username/package-name)');
    }

    const url = `${this.baseUrl}/v1/bundles/${packageName}`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Bundle not found: ${packageName}`);
      }
      const error: any = await response.json().catch(() => ({ error: response.statusText }));
      const errorMessage = typeof error.error === 'string'
        ? error.error
        : error.error?.message || `Failed to get bundle details: ${response.statusText}`;
      throw new Error(errorMessage);
    }

    return response.json() as Promise<BundleDetail>;
  }

  /**
   * Get versions with platform info
   */
  async getVersions(packageName: string): Promise<VersionsResponse> {
    if (!packageName.startsWith('@')) {
      throw new Error('Package name must be scoped (e.g., @username/package-name)');
    }

    const url = `${this.baseUrl}/v1/bundles/${packageName}/versions`;
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`Bundle not found: ${packageName}`);
      }
      const error: any = await response.json().catch(() => ({ error: response.statusText }));
      const errorMessage = typeof error.error === 'string'
        ? error.error
        : error.error?.message || `Failed to get versions: ${response.statusText}`;
      throw new Error(errorMessage);
    }

    return response.json() as Promise<VersionsResponse>;
  }

  /**
   * Detect the current platform
   */
  static detectPlatform(): Platform {
    const platform = process.platform;
    const arch = process.arch;

    // Map Node.js platform names to MCPB spec names
    let os: string;
    switch (platform) {
      case 'darwin':
        os = 'darwin';
        break;
      case 'win32':
        os = 'win32';
        break;
      case 'linux':
        os = 'linux';
        break;
      default:
        os = 'any';
    }

    // Map Node.js arch names to MCPB spec names
    let mcpbArch: string;
    switch (arch) {
      case 'x64':
        mcpbArch = 'x64';
        break;
      case 'arm64':
        mcpbArch = 'arm64';
        break;
      default:
        mcpbArch = 'any';
    }

    return { os, arch: mcpbArch };
  }

  /**
   * Get download info for a bundle version
   */
  async getDownloadInfo(packageName: string, version?: string, platform?: Platform): Promise<DownloadInfo> {
    if (!packageName.startsWith('@')) {
      throw new Error('Package name must be scoped (e.g., @username/package-name)');
    }

    const versionPath = version ? `/versions/${version}` : '/versions/latest';
    const params = new URLSearchParams();

    if (platform) {
      params.set('os', platform.os);
      params.set('arch', platform.arch);
    }

    const queryString = params.toString();
    const url = `${this.baseUrl}/v1/bundles/${packageName}${versionPath}/download${queryString ? `?${queryString}` : ''}`;

    const response = await fetch(url, {
      headers: {
        Accept: 'application/json',
      },
    });

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(version
          ? `Bundle version not found: ${packageName}@${version}`
          : `Bundle not found: ${packageName}`
        );
      }
      const error: any = await response.json().catch(() => ({ error: response.statusText }));
      const errorMessage = typeof error.error === 'string'
        ? error.error
        : error.error?.message || `Failed to get download info: ${response.statusText}`;
      throw new Error(errorMessage);
    }

    return response.json() as Promise<DownloadInfo>;
  }

  /**
   * Download a bundle to a file
   */
  async downloadBundle(downloadUrl: string, outputPath: string): Promise<void> {
    const response = await fetch(downloadUrl);

    if (!response.ok) {
      throw new Error(`Failed to download bundle: ${response.statusText}`);
    }

    const arrayBuffer = await response.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    const fs = await import('fs');
    fs.writeFileSync(outputPath, buffer);
  }
}
